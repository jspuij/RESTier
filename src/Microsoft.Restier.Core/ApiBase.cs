// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License.  See License.txt in the project root for license information.

using System;
using System.Collections.Concurrent;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.OData.Edm;
using Microsoft.Restier.Core.Model;
using Microsoft.Restier.Core.Query;
using Microsoft.Restier.Core.Submit;

namespace Microsoft.Restier.Core
{
    /// <summary>
    /// Represents a base class for an API.
    /// </summary>
    /// <remarks>
    /// <para>
    /// An API configuration is intended to be long-lived, and can be statically cached according to an API type specified when the
    /// configuration is created. Additionally, the API model produced as a result of a particular configuration is cached under the same
    /// API type to avoid re-computing it on each invocation.
    /// </para>
    /// </remarks>
    public abstract class ApiBase : IDisposable, IPropertyBag
    {

        #region Private Members

        private static ConcurrentDictionary<Type, Action<IServiceCollection>> publisherServicesCallback =
            new ConcurrentDictionary<Type, Action<IServiceCollection>>();

        private static readonly Action<IServiceCollection> emptyConfig = _ => { };

        private ApiConfiguration apiConfiguration;

        private readonly DefaultSubmitHandler submitHandler;

        private readonly DefaultQueryHandler queryHandler;
        private readonly IPropertyBag propertyBag;
        private readonly IModelBuilder modelBuilder;

        private readonly Func<IModelMapper> mapperFactory;

        #endregion

        #region Public Properties

        /// <summary>
        /// Gets the <see cref="IServiceProvider"/> which contains all services of this <see cref="ApiConfiguration"/>.
        /// </summary>
        public IServiceProvider ServiceProvider { get; private set; }

        #endregion

        #region Internal Properties

        /// <summary>
        /// Gets the API configuration for this API.
        /// </summary>
        internal ApiConfiguration Configuration
        {
            get
            {
                if (apiConfiguration == null)
                {
                    apiConfiguration = ServiceProvider.GetService<ApiConfiguration>();
                }

                return apiConfiguration;
            }
        }

        /// <summary>
        /// Gets a reference to the Query Handler for this <see cref="ApiBase"/> instance.
        /// </summary>
        internal DefaultQueryHandler QueryHandler => queryHandler;

        #endregion

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiBase" /> class.
        /// </summary>
        /// <param name="serviceProvider">
        /// An <see cref="IServiceProvider"/> containing all services of this <see cref="ApiConfiguration"/>.
        /// </param>
        /// <param name="propertyBag">An <see cref="IPropertyBag"/> implementation to store properties on the ApiBase.</param>
        protected ApiBase(IServiceProvider serviceProvider, IPropertyBag propertyBag)
        {
            Ensure.NotNull(serviceProvider, nameof(serviceProvider));
            Ensure.NotNull(propertyBag, nameof(propertyBag));

            ServiceProvider = serviceProvider;
            this.propertyBag = propertyBag;

            //RWM: This stuff SHOULD be getting passed into a constructor. But the DI implementation is less than awesome.
            //     So we'll work around it for now and still save some allocations.
            //     There are certain unit te
            var queryExpressionSourcer = serviceProvider.GetService<IQueryExpressionSourcer>();
            var queryExpressionAuthorizer = serviceProvider.GetService<IQueryExpressionAuthorizer>();
            var queryExpressionExpander = serviceProvider.GetService<IQueryExpressionExpander>();
            var queryExpressionProcessor = serviceProvider.GetService<IQueryExpressionProcessor>();
            var changeSetInitializer = serviceProvider.GetService<IChangeSetInitializer>();
            var changeSetItemAuthorizer = serviceProvider.GetService<IChangeSetItemAuthorizer>();
            var changeSetItemValidator = serviceProvider.GetService<IChangeSetItemValidator>();
            var changeSetItemFilter = serviceProvider.GetService<IChangeSetItemFilter>();
            var submitExecutor = serviceProvider.GetService<ISubmitExecutor>();
            modelBuilder = serviceProvider.GetService<IModelBuilder>();
            // TODO: JWS: as long as model generation is not deterministic before creation of an ApiBase you get an
            // stack overflow. Apibase tries to instantiate an IModelMapper, which needs an IEdmModel, which is generated by
            // instantiating an ApiBAse by the DI container, which tries to instantiate IModelMApper and so on.
            // By delaying ModelMapper instantiation using a factory, we avoid the Stack Overflow.
            mapperFactory = () => serviceProvider.GetService<IModelMapper>();

            // TODO: JWS: check this in the constructor. But now too many unit tests fail, so we will 
            // save this for a rewrite.
            //if (modelBuilder == null)
            //{
            //    throw new InvalidOperationException(Resources.ModelBuilderNotRegistered);
            //}

            if (queryExpressionSourcer == null)
            {
                // Missing sourcer
                throw new NotSupportedException(Resources.QuerySourcerMissing);
            }

            if (changeSetInitializer == null)
            {
                throw new NotSupportedException(Resources.ChangeSetPreparerMissing);
            }

            if (submitExecutor == null)
            {
                throw new NotSupportedException(Resources.SubmitExecutorMissing);
            }

            queryHandler = new DefaultQueryHandler(queryExpressionSourcer, queryExpressionAuthorizer, queryExpressionExpander, queryExpressionProcessor);
            submitHandler = new DefaultSubmitHandler(changeSetInitializer, submitExecutor, changeSetItemAuthorizer, changeSetItemValidator, changeSetItemFilter);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiBase" /> class.
        /// </summary>
        /// <param name="serviceProvider">
        /// An <see cref="IServiceProvider"/> containing all services of this <see cref="ApiConfiguration"/>.
        /// </param>
        protected ApiBase(IServiceProvider serviceProvider) : this(serviceProvider, new PropertyBag())
        {
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Configure services for this API.
        /// </summary>
        /// <param name="apiType">
        /// The Api type.
        /// </param>
        /// <param name="services">
        /// The <see cref="IServiceCollection"/> with which is used to store all services.
        /// </param>
        /// <returns>The <see cref="IServiceCollection"/>.</returns>
        //[CLSCompliant(false)]
        public static IServiceCollection ConfigureApi(Type apiType, IServiceCollection services)
        {
            // Add core and convention's services
            services = services.AddCoreServices(apiType)
                .AddConventionBasedServices(apiType);

            // This is used to add the publisher's services
            GetPublisherServiceCallback(apiType)(services);

            return services;
        }

        /// <summary>
        /// Adds a configuration procedure for apiType.
        /// This is expected to be called by publisher like WebApi to add services.
        /// </summary>
        /// <param name="apiType">
        /// The Api Type.
        /// </param>
        /// <param name="configurationCallback">
        /// An action that will be called during the configuration of apiType.
        /// </param>
        //[CLSCompliant(false)]
        public static void AddPublisherServices(Type apiType, Action<IServiceCollection> configurationCallback)
        {
            publisherServicesCallback.AddOrUpdate(apiType, configurationCallback, (type, existing) => existing + configurationCallback);
        }

        /// <summary>
        /// Get publisher registering service callback for specified Api.
        /// </summary>
        /// <param name="apiType">The Api type of which to get the publisher registering service callback.</param>
        /// <returns>The service registering callback.</returns>
        //[CLSCompliant(false)]
        public static Action<IServiceCollection> GetPublisherServiceCallback(Type apiType)
        {
            if (publisherServicesCallback.TryGetValue(apiType, out var val))
            {
                return val;
            }

            return emptyConfig;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Asynchronously gets an API model using an API context.
        /// </summary>
        /// <param name="cancellationToken">
        /// An optional cancellation token.
        /// </param>
        /// <returns>
        /// A task that represents the asynchronous
        /// operation whose result is the API model.
        /// </returns>
        public async Task<IEdmModel> GetModelAsync(CancellationToken cancellationToken = default)
        {
            var config = this.Configuration;

            if (config.Model != null)
            {
                return config.Model;
            }

            if (modelBuilder == null)
            {
                throw new InvalidOperationException(Resources.ModelBuilderNotRegistered);
            }

            var source = config.CompleteModelGeneration(out var running);
            if (source == null)
            {
                return await running.ConfigureAwait(false);
            }

            try
            {
                // TODO: JWS: Probably a factory for the context. But later.
                var buildContext = new ModelContext(this, new PropertyBag());
                var model = await modelBuilder.GetModelAsync(buildContext, cancellationToken).ConfigureAwait(false);
                source.SetResult(model);
                return model;
            }
            catch (AggregateException e)
            {
                source.SetException(e.InnerExceptions);
                throw;
            }
            catch (Exception e)
            {
                source.SetException(e);
                throw;
            }
        }

        /// <summary>
        /// Asynchronously submits changes made using an API context.
        /// </summary>
        /// <param name="changeSet">A change set, or <c>null</c> to submit existing pending changes.</param>
        /// <param name="cancellationToken">An optional cancellation token.</param>
        /// <returns>A task that represents the asynchronous operation whose result is a submit result.</returns>
        public async Task<SubmitResult> SubmitAsync(ChangeSet changeSet = null, CancellationToken cancellationToken = default)
        {
            // TODO: JWS: Probably a factory for the context. But later.
            var submitContext = new SubmitContext(this, changeSet, new PropertyBag());
            return await submitHandler.SubmitAsync(submitContext, cancellationToken).ConfigureAwait(false);
        }

        #endregion

        /// <summary>
        /// 
        /// </summary>
        /// <param name="namespaceName"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        internal Type EnsureElementType(string namespaceName, string name)
        {
            Type elementType = null;

            var mapper = mapperFactory();

            if (mapper != null)
            {
                // TODO: JWS: Probably a factory for the context. But later.
                var modelContext = new ModelContext(this, new PropertyBag());
                if (namespaceName == null)
                {
                    mapper.TryGetRelevantType(modelContext, name, out elementType);
                }
                else
                {
                    mapper.TryGetRelevantType(modelContext, namespaceName, name, out elementType);
                }
            }

            if (elementType == null)
            {
                throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture, Resources.ElementTypeNotFound, name));
            }

            return elementType;
        }

        #region IDisposable Pattern

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="disposing"></param>
        /// <remarks>RWM: See https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1063-implement-idisposable-correctly?view=vs-2017 for more information.</remarks>
        protected virtual void Dispose(bool disposing)
        {
            // RWM: This Dispose method isn't implemented properly, and may actually be doing more harm than good.
            //      I'm leaving it for now so we can open an issue and ask the question if this class needs to do more on Dispose,
            //      But I have a feeling we need to kill this with fire.   
            if (disposing)
            {
                // free managed resources
            }
        }

        #endregion

        #region IPropertyBag Forwarding

        /// <inheritdoc />
        public T GetProperty<T>(string name)
        {
            return propertyBag.GetProperty<T>(name);
        }

        /// <inheritdoc />
        public object GetProperty(string name)
        {
            return propertyBag.GetProperty(name);
        }

        /// <inheritdoc />
        public bool HasProperty(string name)
        {
            return propertyBag.HasProperty(name);
        }

        /// <inheritdoc />
        public void RemoveProperty(string name)
        {
            propertyBag.RemoveProperty(name);
        }

        /// <inheritdoc />
        public void SetProperty(string name, object value)
        {
            propertyBag.SetProperty(name, value);
        }

        #endregion
    }

}